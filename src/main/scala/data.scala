package org.apache.mesos.edsl.data

import org.apache.{mesos => M}
import org.apache.mesos.{Protos => P}
import scala.concurrent.{Channel}

/**
 * events generated by the callbacks to mesos.Scheduler 
 */
sealed abstract class SchedulerEvents
final case class ResourceOffer(offers: java.util.List[P.Offer]) extends SchedulerEvents
final case class OfferRescinded(id: P.OfferID) extends SchedulerEvents
final case class Disconnected() extends SchedulerEvents
final case class Reregistered(masterInfo: P.MasterInfo) extends SchedulerEvents
final case class SlaveLost(slaveID: P.SlaveID) extends SchedulerEvents
final case class Error(message: String) extends SchedulerEvents
final case class StatusUpdate(status: P.TaskStatus) extends SchedulerEvents
final case class FrameworkMessage(status: P.ExecutorID, slaveId: P.SlaveID, data: Array[Byte]) extends SchedulerEvents
final case class Registered(frameworkId: P.FrameworkID, masterInfo: P.MasterInfo) extends SchedulerEvents
final case class ExecutorLost(executorId: P.ExecutorID, slaveID: P.SlaveID, status: Int) extends SchedulerEvents

/**
 * Object to keep track of the scheduler state
 * @param driver the mesos.SchedulerDriver
 * @param channel the channel used to create the Scheduler
 * @param offers the current list of available offers
 * @param lookahead the event the SchedulerM monad is current processing over
 */
final case class SchedulerState(driver: M.SchedulerDriver, channel: Channel[SchedulerEvents], offers:List[P.Offer], lookahead:Option[SchedulerEvents])
